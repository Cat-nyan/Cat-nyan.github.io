[{"title":"JVM-类加载子系统","url":"/2021/09/03/jvm-class-loader-subsystem/","content":"\n## 概述\n\n当编译完java程序后，如果你足够细心，会发现在某个特定的文件夹里总能发现以`.class`结尾的文件，也称之为字节码文件，而这正是用来储存中间代码的容器，这里面描述了类和接口的各种信息，只有当字节码文件加载到虚拟机后才能够运行和使用，这个过程由类加载子系统来完成，大致流程如下：\n\n<!--more-->\n\n![2021-9-3-1](2021-9-3-1.jpg)\n\n## Loading-加载\n\n这里的“加载”是“类加载”过程的一个阶段，在这个阶段，虚拟机需要完成下方**三件事**：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的**java.lang.Class**对象，作为方法区这个类的各种数据的访问入口\n\n\n\n## Linking-连结\n\n加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍旧属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。\n\n### Verify-验证\n\n验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n\n\n验证阶段主要完成下面4个阶段的检验动作：\n\n1. **文件格式验证**\n\n   第一阶段要检验字符流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理\n\n2. **元数据验证**\n\n   第二阶段是对字节码表述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求\n\n3. **字节码验证**\n\n   第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全事件\n\n4. **符号引用验证**\n\n   最后一个阶段的验证发生在虚拟机将符号引用转换为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验\n\n{% note info %}\n\n常量池用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如`String s = \"xiaohei\"`这种申明方式\n\n{% endnote %}\n\n\n\n### Prepare-准备\n\n准备阶段是正式为**类变量**分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先这时候进行内存分配的仅包括**类变量**(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况\"下是数据类型的零值，假设一个类变**age**的定义为:\n\n```java\nprivate static int age = 20;\n```\n\n那变量**age**在准备阶段过后的初始值将会是0而不是20，因为这时候尚未开始执行任何Java方法，而把**age**赋值为20的`putstatic`指令是程序被编译后，存放在构造器`< clint>()`方法之中，所以这个赋值动作在初始化阶段才会执行。\n\n{% note info %}\n\n当然还有一些**特殊情况**，如果类的字段属性为ConstantValue属性，那么在准备阶段变量`value`就会初始化为ConstantValue属性所指定的值，假设类变量**value**定义为：\n\n```java\nprivate static final int value = 123;\n```\n\n编译时Javac将会为**value**生成ConstantValue属性，在准备阶段虚拟机根据这个属性的设置将**value**赋值为123\n\n{% endnote %}\n\n\n\n### Resolve-解析\n\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中符号引用以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。\n\n{% note info %}\n\n **符号引用**(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一-定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的， 因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。\n\n{% endnote %}\n\n{% note info %}\n\n**直接引用**(Direct References)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。\n\n{% endnote %}\n\n解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符\n\n\n\n## Initialization-初始化\n\n类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。\n\n在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达:初始化阶段是执行类构造器`< clinit>()`方法的过程。\n\n### < clinit>()\n\n`< clinit>()`方法是由编译器自动收集类中的所有**类变量**的赋值动作和**静态语句块**(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。\n\n```java\n    static {\n        value = 20;//可以赋值\n        System.out.println(value);//编译失败，非法向前引用\n    }\n\n    private static int value = 10;\n```\n\n{% note info %}\n\n`< clinit><()`方法对于类或接口来说并不是必需的，如果-个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`< clinit>()`方法。\n\n{% endnote %}\n\n\n\n## ClassLoader-类加载器\n\n### Java类加载体系\n\n JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：\n\n- Bootstrap ClassLoader\t启动类加载器\n- Extension ClassLoader    扩展类加载器 \n- Application ClassLoader  应用程序类加载器\n\n从Java虚拟机的角度来讲，只存在两种不同的类加载器:一种是启动类加载器( Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分;另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLader\n\n**启动类加载器**(BootstrapClassLoader)：负责将 <JAVA_HOME>\\lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作\n\n**扩展类加载器**(ExtClassLoader ,JDK 1.9 之后，改名为 PlatformClassLoader)：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器\n\n**应用程序类加载器**(AppClassLoader)：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）类加载器\n\n\n\n在JDK16中，可以输入以下代码，查看以上这些类加载器的实现类：\n\n```java\n@Test\nvoid test(){\n    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();\n    System.out.println(appClassLoader);\n    ClassLoader extClassLoader = appClassLoader.getParent();\n    System.out.println(extClassLoader);\n    ClassLoader bootstrapClassLoader = extClassLoader.getParent();\n    System.out.println(bootstrapClassLoader);\n}\n```\n\n结果：\n\n```TXT\njdk.internal.loader.ClassLoaders$AppClassLoader@66d3c617\njdk.internal.loader.ClassLoaders$PlatformClassLoader@1e9e725a\nnull\n```\n\n启动类加载器的结果为**null**是因为其使用了C++语言实现\n\n### 加载器之间的关系——双亲委派模型\n\n除了以上三种类加载器外，可能还存在由用户自定义的类加载器，他们之间的层次关系模型如下图所示\n\n![2021-9-3-2](2021-9-3-2.jpg)\n\n双亲委派模型的工作过程是如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，启动类加载器先去缓存中查找，之后在去指定路径查找，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载，每一层的类加载器都会按照这种顺序进行类的加载，具体流程见下图：\n\n![2021-9-4-1](2021-9-4-1.jpg)\n","tags":["JVM"]},{"title":"Tomcat日志乱码问题","url":"/2021/09/01/tomcat-log-garbled-issue/","content":"\n## Issue\n\n在Windows环境下，启动Tomcat时，将会在控制台输出日志，但是日志却是乱码\n\n<!--more-->\n\n![image-20210901201808160](image-20210901201808160.png)\n\n然而，网上的大多是解决方案是更改编辑器的编码格式，或者是修改注册表，但是往往并不能从根本上解决问题\n\n## 原因\n\n可以看到控制台的编码格式GBK\n\n![image-20210901202058901](image-20210901202058901.png)\n\n而新版Tomcat的日志输出格式却是UTF-8\n\n> 旧版是GBK格式，所以旧版并不存在乱码问题\n\n![image-20210901202315665](image-20210901202315665.png)\n\n![image-20210901202356253](image-20210901202356253.png)\n\n控制台的文字编码格式和Tomcat的日志输出格式不一致，当然会引起乱码问题\n\n## 解决方案\n\n既然知道了原因，那么直接把输出的日志编码更改为GBK就行了,至此，CMD控制台和编辑器(如IDEA)里的控制台都不会再出现乱码问题了。\n\n![image-20210901202905917](image-20210901202905917.png)\n\n","tags":["Tomcat"]},{"title":"Hello World","url":"/2021/08/31/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Github提交项目","url":"/2021/08/24/github-commit-project/","content":"\n## 创建仓库\n\n**在提交项目之前，你首先需要创建一个新的仓库**\n\n<!--more-->\n\n![image-20210824122112924](image-20210824122112924.png)\n\n## Clone 仓库\n\n**进入你刚创建的仓库，点击“Code”，把你的仓库地址复制下来**\n\n![image-20210824122651816](image-20210824122651816.png)\n\n\n\n**打开git控制台，在你想要`clone`项目的地方执行`git clone <url>`命令**\n\n> < url>指你刚才所复制的仓库地址\n\n![image-20210824123515708](image-20210824123515708.png)\n\n\n\n## Commit 项目\n\n**进入刚刚clone下来的文件夹中，文件夹的名字就是创建的仓库名称**\n\n![image-20210824123910730](image-20210824123910730.png)\n\n{% note warning%}\n\n注意看路径后的蓝色字体，它代表了该项目所属的分支，自2020-10-1起Github中所有新建仓库的默认分支都已经从`master`改为了`main`，但网上大部分教程还是基于`master`分支，本博文将基于`main`分支来提交项目\n\n{% endnote %}\n\n**将想要提交的项目文件复制到刚下载的仓库文件夹中，之后执行`git add .`命令文件添加到暂存区中，从而保存历史版本**\n\n![image-20210824125345149](image-20210824125345149.png)\n\n\n\n**在执行commit命令之前，你可能需要先设置以下用户信息，用以连接你的Github账户**\n\n```BASH\n$ git config --global user.name '你的用户名'\n$ git config --global user.email 你的Github账号邮箱\n```\n\n\n\n\n\n**执行`git commit -m [message]`命令将暂存区内容添加到本地仓库中，其中`[message] `是一些备注信息，如 : 这次修改哪些文件，修复了哪些bug均可。**\n\n> 这里以`git commit -m \"first commit\"`为例\n\n![image-20210824130348946](image-20210824130348946.png)\n\n\n\n**最后执行`git push origin main`将本地仓库推送到你的在线仓库中**\n\n![image-20210824131359872](image-20210824131359872.png)\n\n\n\n## 项目提交成功\n\n**在执行完上面的所有命令后，你已经可以在仓库中查看新提交的代码了**\n\n![image-20210824131556845](image-20210824131556845.png)\n\n\n\n\n\n","tags":["Github"]},{"title":"SpringBoot简易整合Shiro","url":"/2021/08/23/springboot-integrate-shiro/","content":"\n## 创建SpringBoot项目\n\n在创建项目时添加以下依赖项：\n\n<!--more-->\n\n![image-20210823204505806](image-20210823204505806.png)\n\n\n\n## 添加依赖项\n\n```XML\n<dependency>\n    <groupId>org.apache.shiro</groupId>\n    <artifactId>shiro-spring</artifactId>\n    <version>1.7.1</version>\n</dependency>\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3.1</version>\n</dependency>\n```\n\n\n\n## 向MySQL中添加数据\n\n项目中用到的具体数据数据如下图所示，为了减少项目复杂性，把用户、角色、权限全部整合到了user表上：\n\n![image-20210823210913360](image-20210823210913360.png)\n\n\n\n**生成该表的user.sql文件内容**\n\n```SQL\n-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)\n--\n-- Host: 127.0.0.1    Database: mybatis\n-- ------------------------------------------------------\n-- Server version\t8.0.18\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!50503 SET NAMES utf8mb4 */;\n/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;\n/*!40103 SET TIME_ZONE='+00:00' */;\n/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\n/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\n/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;\n/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\n\n--\n-- Table structure for table `user`\n--\n\nDROP TABLE IF EXISTS `user`;\n/*!40101 SET @saved_cs_client     = @@character_set_client */;\n/*!50503 SET character_set_client = utf8mb4 */;\nCREATE TABLE `user` (\n                        `id` int(11) DEFAULT NULL,\n                        `username` varchar(40) DEFAULT NULL,\n                        `password` varchar(40) DEFAULT NULL,\n                        `perms` varchar(20) DEFAULT NULL,\n                        `role` varchar(255) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n/*!40101 SET character_set_client = @saved_cs_client */;\n\n--\n-- Dumping data for table `user`\n--\n\nLOCK TABLES `user` WRITE;\n/*!40000 ALTER TABLE `user` DISABLE KEYS */;\nINSERT INTO `user` (`id`, `username`, `password`, `perms`, `role`) VALUES (1,'zs','123123',NULL,NULL),(2,'ls','123123','manage',NULL),(3,'ww','123123','manage','admin');\n/*!40000 ALTER TABLE `user` ENABLE KEYS */;\nUNLOCK TABLES;\n/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;\n\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\n/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\n/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\n\n-- Dump completed on 2021-08-23 20:57:12\n\n```\n\n\n\n## 项目总体结构\n\n项目结构如下图所示，可按需求自行调整\n\n![image-20210823211858140](image-20210823211858140.png)\n\n\n\n## 编写实体类-User\n\n```JAVA\nimport lombok.Data;\n\n@Data\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    private String perms;\n    private String role;\n}\n```\n\n\n\n## 编写mapper接口-UserMapper\n\n```JAVA\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.catnyan.entity.User;\n\npublic interface UserMapper extends BaseMapper<User>{\n}\n```\n\n\n\n## 编写service类\n\n**UserService接口**\n\n```JAVA\nimport com.catnyan.entity.User;\n\npublic interface UserService {\n    public User findByUsername(String username);\n}\n```\n\n**UserServiceImpl类（实现了UserService接口）**\n\n```JAVA\nimport javax.annotation.Resource;\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    public User findByUsername(String username) {\n        QueryWrapper<User> wrapper = new QueryWrapper<>();\n        wrapper.eq(\"username\", username);\n        return  userMapper.selectOne(wrapper);\n    }\n}\n```\n\n\n\n## 配置数据源并开启mybatis-plus日志功能\n\n在`resources`文件中创建`application.yaml`文件，并添加如下配置：\n\n```yaml\n# DataSource Config\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=GMT%2B8\n    username: root\n    password: 123456\n\n# mybatis-plus日志开启\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n\n\n\n## MySQL连接测试\n\n请在测试类中检测mapper接口及service接口是否正常工作，测试类代码：\n\n```JAVA\nimport com.catnyan.entity.User;\nimport com.catnyan.mapper.UserMapper;\nimport com.catnyan.service.UserService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.annotation.Resource;\nimport java.util.List;\n\n@SpringBootTest\nclass DemoApplicationTests {\n    @Resource\n    private UserMapper userMapper;\n    @Resource\n    private UserService userService;\n\n    @Test\n    void mapper() {\n        List<User> users = userMapper.selectList(null);\n        users.forEach(System.out::println);\n    }\n\n    @Test\n    void service() {\n        User user = userService.findByUsername(\"zs\");\n        System.out.println(user);\n    }\n\n}\n\n```\n\n**UserMapper接口预期结果**\n\n![image-20210823214839427](image-20210823214839427.png)\n\n**UserService接口预期结果**\n\n![image-20210823215002310](image-20210823215002310.png)\n\n\n\n> 如果以上预取结果全部实现，则可继续剩余流程，否则请检查代码是否正确\n\n\n\n## 编写自定义Realm-ShiroRealm\n\n```java\nimport com.catnyan.entity.User;\nimport com.catnyan.service.UserService;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.subject.Subject;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Component\npublic class ShiroRealm extends AuthorizingRealm {\n    @Resource\n    private UserService userService;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        //获取当前登录的用户信息\n        Subject subject = SecurityUtils.getSubject();\n        User user = (User) subject.getPrincipal();\n        //设置角色\n        Set<String> roles = new HashSet<>();\n        roles.add(user.getRole());\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles);\n        //设置权限\n        info.addStringPermission(user.getPerms());\n        return info;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        //authenticationToken将由你提交的表单生成，登录信息全部被封装在token中\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        User user = userService.findByUsername(token.getUsername());\n        if (user != null) {\n            //密码不正确将会抛出IncorrectCredentialsException\n            return new SimpleAuthenticationInfo(user,user.getPassword(),getName());\n        }\n        //未找到用户记录，将会抛出UnknownAccountException\n        return null;\n    }\n}\n\n```\n\n\n\n## 编写shiro配置类-ShiroConfig\n\n### 认证与授权规则：\n\n**认证过滤器**\n\n- anon ：无需认证\n- authc ：必须认证\n- user ：不一定通过认证，只要曾经被 Shiro 记录即可，比如：记住我\n\n**授权过滤器**\n\n- perms ：必须拥有某个权限才能访问\n- role ：必须拥有某个角色才能访问\n- port ：请求的端口必须是指定值才可以\n- rest ：rest 风格拦截器，自动根据请求方法构建权限字符串\n- ssl ：必须是安全的 URL 请求，协议 HTTPS\n\n```JAVA\nimport com.catnyan.shiro.ShiroRealm;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.LinkedHashMap;\n\n@Configuration\npublic class ShiroConfig {\n\n    @Bean\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) {\n        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();\n        factoryBean.setSecurityManager(securityManager);\n        //权限设置\n        LinkedHashMap<String, String> filterMap = new LinkedHashMap<>();\n        filterMap.put(\"/main\",\"authc\");\n        filterMap.put(\"/manage\", \"perms[manage]\");\n        filterMap.put(\"/administrator\", \"roles[admin]\");\n        factoryBean.setFilterChainDefinitionMap(filterMap);\n        //设置登录界面\n        factoryBean.setLoginUrl(\"/login\");\n        //设置未授权页面\n        factoryBean.setUnauthorizedUrl(\"/unauthc\");\n\n        return factoryBean;\n    }\n\n    @Bean\n    public DefaultWebSecurityManager defaultWebSecurityManager(ShiroRealm shiroRealm) {\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroRealm);\n        return securityManager;\n    }\n}\n```\n\n\n\n## 编写Web资源\n\n**index.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>index</h1>\n<!--如果登录成功，则显示登录信息-->\n<div th:if=\"${session.user != null}\">\n    <span th:text=\"${session.user.username}+'欢迎回来'\"></span><a href=\"/logout\">退出</a>\n</div>\n<a href=\"/main\">main</a> | <a href=\"/manage\">manage</a> | <a href=\"/administrator\">administrator</a>\n\n</body>\n</html>\n```\n\n\n\n**login.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>Login</h1>\n<form action=\"/login\" method=\"post\">\n    用户名：<input type=\"text\" name=\"username\"><br>\n    密码：<input type=\"password\" name=\"password\"><br>\n    <span th:text=\"${msg}\" style=\"color: red\"></span><br>\n    <input type=\"submit\" value=\"登录\">\n</form>\n\n</body>\n</html>\n```\n\n\n\n**main.html**\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>首页</h1>\n\n</body>\n</html>\n```\n\n\n\n**manage.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>manage</h1>\n\n</body>\n</html>\n```\n\n\n\n**administrator.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>administrator</h1>\n\n</body>\n</html>\n```\n\n\n\n## 编写controller类-UserController\n\n```java\nimport com.catnyan.entity.User;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.subject.Subject;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class UserController {\n\n    @GetMapping(\"/{url}\")\n    public String redirect(@PathVariable(\"url\") String url) {\n        return url;\n    }\n\n    @PostMapping(\"/login\")\n    public String login(String username, String password, Model model) {\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n        try {\n            subject.login(token);\n            User user = (User) subject.getPrincipal();\n            subject.getSession().setAttribute(\"user\", user);\n            return \"/index\";\n        } catch (UnknownAccountException e) {\n            e.printStackTrace();\n            model.addAttribute(\"msg\", \"用户不存在！\");\n        } catch (IncorrectCredentialsException e) {\n            e.printStackTrace();\n            model.addAttribute(\"msg\", \"密码错误！\");\n        }\n        return null;\n    }\n\n    /**\n     * 没有权限时将直接显示错误信息：”未授权，无法访问“\n     */\n    @GetMapping(\"/unauthc\")\n    @ResponseBody\n    public String unauthc() {\n        return \"未授权，无法访问\";\n    }\n\n    @GetMapping(\"/logout\")\n    public String logout() {\n        Subject subject = SecurityUtils.getSubject();\n        //logout方法将会移除session、principals、authenticated\n        subject.logout();\n        return \"/login\";\n    }\n}\n```\n\n\n\n## 开始测试\n\n上述准备工作全部完成后，就可以开始测试**Shiro**是否能正常工作了。\n\n**启动项目**\n\n![image-20210823223435051](image-20210823223435051.png)\n\n\n\n**进入主界面**\n\n当项目启动成功后，在浏览器中输入`localhost:8080`,进入主界面如下图所示\n\n![image-20210823223636842](image-20210823223636842.png)\n\n\n\n**未登录状态**\n\n此时你处于未登录状态，点击任意一个连接，都会被重定向到`login`页面，用户名或密码错误都会抛出异常并将提示信息展示到页面上，只有登录成功后才具有访问某些页面的权限，\n\n![image-20210823224020653](image-20210823224020653.png)\n\n![image-20210823224244327](image-20210823224244327.png)\n\n![image-20210823224529880](image-20210823224529880.png)\n\n\n\n**登录状态**\n\n登录成功后将会返回至`index`页面，并且登录的用户信息也会显示出来\n\n![image-20210823224944792](image-20210823224944792.png)\n\n\n\n此时用户只具有一部分访问权限，如用户\"**zs**\"只能访问`main`页面，访问其他页面时将会出现提示”未授权，无法访问“\n\n![image-20210823225427764](image-20210823225427764.png)\n\n\n\n**退出登录**\n\n在`index`页面可以点击“退出”来注销当前用户，此时关于该用户的session信息、认证信息、权限信息都将会移除，之后会重定向至`login`页面\n\n![image-20210823230025189](image-20210823230025189.png)\n\n\n\n## 总结\n\n至此关于SpringBoot整合Shiro的简易整合已经全部完成，除了用户“zs”，你也可登录其他用户如“ls”、\"ww\"等，他们分别具有不同的权限，因此可访问的页面也各不相同，具体效果请自行测试。\n","tags":["Shiro"]},{"title":"Shiro简述","url":"/2021/08/23/shiro-brief-introduction/","content":"\n## Shiro\n\n是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。\n\nShiro 就是用来解决安全管理的系统化框架。\n\n<!--more-->\n\n> [Shiro官网](https://shiro.apache.org/)\n\n## Shiro所有功能\n\n![image-20210823134457841](image-20210823134457841.png)\n\n**核心功能**\n\n- Authentication ：身份认证/登录，验证用户是不是拥有相应的身份\n- Authorization ：授权，即权限验证，判断某个已经认证过的用户是否拥有某些权限访问某些资源，一般授权会有角色授权和权限授权\n- SessionManagement ：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的，web 环境中作用是和 HttpSession 是一样的\n- Cryptography ：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储\n\n**附加功能**\n\n- Web Support  ：Web支持，可以非常容易的集成到Web环境\n- Caching ：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率\n- Concurrency ：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去\n- Testing ：提供测试支持\n- Run As ：允许一个用户假装为另一个用户的身份进行访问\n- Remember Me ：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了\n\n\n\n# Shiro核心组件\n\n- UsernamePasswordToken ：Shiro 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token\n- SecurityManager ：Shiro 的核心部分，负责安全认证和授权\n- Suject ：Shiro 的一个抽象概念，包含了用户信息，通常我们会将Subject对象理解为一个用户，同样的它也有可能是一个第三方程序，它是一个抽象的概念，可以理解为任何与系统交互的“东西”都是Subject。\n- Realm ：开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 Realm 中\n- AuthenticationInfo ：用户的角色信息集合，认证时使用\n- AuthorizationInfo ：角色的权限信息集合，授权时使用\n- DefaultWebSecurityManager ：安全管理器，开发者自定义的 Realm 需要注入到 DefaultWebSecurityManager 进行管理才能生效\n- ShiroFilterFactoryBean ：过滤器工厂，Shiro 的基本运行机制是开发者定制规则，Shiro 去执行，具体的执行操作就是由 ShiroFilterFactoryBean 创建的一个个 Filter 对象来完成\n\n","tags":["Shiro"]},{"title":"Linux进程管理","url":"/2021/08/19/linux-process-manage/","content":"\n## 显示进程状态-ps\n\n**参数及说明：**\n\n- -a 显示所有终端机下执行的程序，除了阶段作业领导者之外\n\n**参考实例**\n\n把所有进程显示出来\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# ps -aux\n```\n\n<!--more-->\n\n查看与某个进程有关的所有信息(如:mysql)\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# ps -aux|grep mysql\n```\n\n\n\n## 以树状图显示进程-pstree\n\n**参数及说明：**\n\n- -a 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示\n- -h 列出树状图时，特别标明现在执行的程序\n\n\n\n## 杀死进程-kill\n\n**参数及说明：**\n\n- -l 列出系统支持的信号\n\n**参考实例**\n\n列出系统支持的信号列表\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# kill -l\n```\n\n杀掉PID为1951的进程\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# kill -9 1951\n```\n\n","tags":["Linux"]},{"title":"Linux磁盘管理","url":"/2021/08/19/linux-disk-manage/","content":"\n## 显示磁盘空间使用情况-df\n\n**参数及说明：**\n\n- -h 以容易阅读的方式显示\n- -t< 文件系统类型> 只显示指定类型的文件系统\n\n<!--more-->\n\n## 查看空间-du\n\ndu命令的英文全称是“Disk Usage”，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区。\n\n**参数及说明：**\n\n- -a 显示目录中所有文件大小\n- -h 以易读方式显示文件大小\n- -k 以KB为单位显示文件大小\n- -m 以MB为单位显示文件大小\n- -g 以GB为单位显示文件大小\n- -s 仅显示总计\n\n","tags":["Linux"]},{"title":"Linux用户组管理","url":"/2021/08/19/linux-group-manage/","content":"\n## 新建用户组-groupadd\n\n**参数及说明：**\n\n- -g ：指定新建工作组的id\n- -r ：创建系统工作组，系统工作组的组ID小于500\n\n<!--more-->\n\n**参考实例**\n\n使用-g参数新建develop工作组名，1005是工作组id\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# groupadd -g 1005 develop\n```\n\n使用-r创建系统工作组\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# groupadd -r -g 368 develop\n```\n\n\n\n## 删除用户组-groupdel\n\n**参考实例**\n\n使用groupdel命令删除develop用户组\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# groupdel develop\n```\n\n查看develop组是否删除成功\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# more /etc/group|grep develop\n```\n\n> 通过查看/etc/group配置文件里面不存在develop组，说明已经被删除了。\n\n\n\n## 更改用户组属性-groupmod\n\n**参数及说明：**\n\n- -g ：设置欲使用的群组识别码\n- -n ：设置欲使用的群组名称\n\n**参考实例**\n\n更改develop用户组为test\n\n```\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# groupmod -n test develop \n```\n\n","tags":["Linux"]},{"title":"Linu系统用户账号的管理","url":"/2021/08/18/linux-user-manager/","content":"\n## 添加新账户\n\n> useradd -m 用户名\n\n- -m 自动创建这个用户的主目录\n\n**参考实例**\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# useradd -m catnyan\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# ls\ncatnyan redis www\n```\n\n<!--more-->\n\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。\n\n\n\n## 删除账号\n\n> userdel -r 用户名\n\n- -r 此命令删除用户在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\n\n**参考实例**\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# userdel -r catnyan\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# ls\nredis www\n```\n\n\n\n## 修改账号-usermod\n\n**参数及说明：**\n\n- -d ：修改用户登入时的目录\n- -u ：修改用户UID\n- -l ：修改用户账号名称\n- -L ：锁定用户密码，使密码无效\n- -U ：接触密码锁定\n\n**参考实例**\n\n更改登录目录\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# usermod -d /home/catnyan root\n```\n\n改变用户的uid\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# usermod -u 777 root\n```\n\n修改用户名为linux\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# usermod -l Linux catnyan\n```\n\n锁定catnyan的密码\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# usermod -L catnyan\n```\n\n解锁catnyan的密码\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# usermod -U catnyan\n```\n\n\n\n## 切换用户-su\n\n**参考实例**\n\n切换到catnyan用户\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ home]# su catnyan\n[catnyan@iZ8vbb5zkeytv121vb0l5wZ home]$\n```\n\n> - 在`su catnyan`中间加上`-`将会自动进入用户的主目录\n> - 输入`exit`将返回root用户\n\n\n\n## 修改用户账户密码-passwd\n\n**参数及说明：**\n\n- -d ：删除密码\n- -l ：锁定用户密码，无法被用户自行修改\n- -u ：解开已锁定用户密码，允许用户自行修改\n- -e ：密码立即过期，下次登陆强制修改密码\n- -k ：保留即将过期的用户在期满后能仍能使用\n- -S ：查询密码状态\n\n**参考实例**\n\n修改当前登陆的账户密码\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# passwd\n```\n\n修改其他用户密码(假设有catnyan用户)\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# passwd catnyan\n```\n\n锁定密码不允许用户修改\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# passwd -l catnyan\n```\n\n解除锁定密码，允许用户修改\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# passwd -U catnyan\n```\n\n","tags":["Linux"]},{"title":"vim的使用","url":"/2021/08/18/linux-vim/","content":"\nvim分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。\n\n<!--more-->\n\n## 命令模式\n\n**常用命令**\n\n- i 切换到输入模式，以输入字符\n- x 删除当前光标所在处的字符\n- : 切换到底线命令模式，以在最底一行输入命令\n- G 移动到文档最后一行\n- gg 移动到文档第一行\n- n Space n表示数字，在输入数字后按空格将向后移动n个字符\n- n Enter 向下移动n行\n- /word 向光标之下寻找一个名称为 word 的字符串。取消高亮可输入`:noh`，n键转到下一个搜索结果，N键转到上一个搜索结果\n- ?word 向光标之上寻找一个字符串名称为 word 的字符串。取消高亮可输入`:noh`\n\n\n\n## 输入模式\n\n| 按键                | 说明                                            |\n| ------------------- | ----------------------------------------------- |\n| 字符按键及Shift组合 | 输入字符                                        |\n| Enter               | 换行                                            |\n| Backspace           | 删除光标前的一个字符                            |\n| Delete              | 删除光标后的一个字符                            |\n| 方向键              | 在文本中移动光标                                |\n| Insert              | 切换光标为输入/替换模式，光标将变成竖线或下划线 |\n| Esc                 | 退出输入模式，切换到命令模式                    |\n\n\n\n## 底线命令模式\n\n| 命令      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| :w        | 将编辑的数据写入硬盘档案中(常用)                             |\n| :q        | 离开 vi (常用)                                               |\n| :wq       | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |\n| ZZ        | 大写ZZ，如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) |\n| :set nu   | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |\n| :set nonu | 取消行号                                                     |\n\n","tags":["vim"]},{"title":"创建文件的多种方式(Linux)","url":"/2021/08/18/linux-create-file/","content":"\n## touch\n\ntouch命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。\n\ntouch命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。\n\n<!--more-->\n\n> 注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有写文件的访问权限。\n\n常用参数及说明：\n\n- -a ：改变档案的读取时间记录\n- -m ：改变档案的修改时间记录\n- -c ：不创建新文件\n\n**参考实例**\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# touch test.c\n```\n\n\n\n## vi和vim\n\nvim内容较多，会单独开博文进行补充\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# vi test.c\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# vim hello.c\n```\n\n\n\n## >和>>\n\n**>**\n\n直接覆盖原文件，不会有任何提示\n\n**>>**\n\n追加在原文件末尾，不会覆盖原文件的内容\n\n\n\n**直接用>创建空白文件**\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# > test.cls 创建文件（将结果写入文件）\n```\n\n**ls 创建文件（将结果写入文件）**\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# ls > test.ini\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# ls >> test.ini\n```\n\n","tags":["Linux"]},{"title":"文件内容查看(Linux)","url":"/2021/08/18/linux-file-content-view/","content":"\n## 在终端设备上显示文件内容-cat\n\n参数及说明：\n\n- -n ：显示行数（空行也编号）\n- -s ：显示行数（多个空行算一个编号）\n- -b ：显示行数（空行不编号）\n- -E ：每行结束处显示$符号\n- -T ：将TAB字符显示为 ^I符号\n- -v ：列出一些看不出来的特殊字符\n- -A ：等价于 -vET组合\n\n<!--more-->\n\n## 显示文本文件内容-more\n\nmore命令用于将内容较长的文本文件内容（不能在一屏显示完）进行分屏显示，并且支持在显示时定位关键字。而对于内容较少的文本文件内容则推荐使用cat命令查看。\n\n**参数及说明**:\n\n- -num ：指定每屏显示的行数\n- -d ：提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声\n\n**命令内部操作**：\n\n- Space键：显示文本的下一屏内容\n- Enter键：向下n行，需要定义，默认为1行\n- H键：显示帮助屏\n- B键：显示上一屏内容\n- Q键：退出more命令\n- Ctrl+F、空格键：向下滚动一屏\n- Ctrl+B：返回上一屏\n- = ： 输出当前的行号\n- ：f ：输出文件名和当前的行号\n- V：调用vi编辑器\n- ! ：调用Shell，并执行命令\n\n\n\n## 分页显示工具-less\n\n浏览文字档案的内容，用less命令显示文件时，PageUp键向上翻页，PageDown键向下翻页，要退出less程序，应按Q键。\n\nless的作用与more十分相似，不同点为less命令允许用户向前或向后浏览文件，而more命令只能向前浏览 。\n\n**命令内部操作**：\n\n- b 向后翻一页\n- d 向后翻半页\n- h 显示帮助界面\n- Q 退出less 命令\n- u 向前滚动半页\n- y 向前滚动一行\n- Space键 滚动一页\n- Enter键 滚动一行\n\n","tags":["Linux"]},{"title":"修改文件属性(Linux)","url":"/2021/08/18/linux-modify-file-attributes/","content":"\n## 更改文件用户组-chgrp\n\n参数及说明：\n\n- -c ：效果类似”-v”参数，但仅回报更改的部分\n- -f ：不显示错误信息\n- -h ：对符号连接的文件作修改，而不更动其他任何相关文件\n- -R ：递归处理，将指定目录下的所有文件及子目录一并处理\n- -v ：显示指令执行过程\n- --reference ：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同\n\n<!--more-->\n\n##  改变文件或目录用户和用户组-chown\n\n参数及说明：\n\n- -R ：对目前目录下的所有文件与子目录进行相同的拥有者变更\n- -c ：若该文件拥有者确实已经更改，才显示其更改动作\n- -f ：若该文件拥有者无法被更改也不要显示错误讯息\n- -h ：只对于连结(link)进行变更，而非该 link 真正指向的文件\n- -v ：显示拥有者变更的详细资料\n\n\n\n## 改变文件或目录权限-chmod\n\n参数及说明：\n\n- -c ：若该文件权限确实已经更改，才显示其更改动作\n- -f ：若该文件权限无法被更改也不显示错误讯息\n- -v ：显示权限变更的详细资料\n- -R ：对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n\n\n\nLinux文件属性有两种设置方法，一种是数字，一种是符号。\n\n**符号设置**\n\n如果我们需要将**file.txt**文件权限设置为`-rwxr-xr--`，可以使用`chmod u=rwx,g=rx,o=r file.txt`进行设置\n\n其中**u,g,o**代表三种身份权限，此外，还有**a**\n\n- u ：--user 属主权限\n- g ：--group 属组权限\n- o ：--other 其他用户权限\n- a ：--all 全部用户\n\n![image-20210818151051933](image-20210818151051933.png)\n\n**数字设置**\n\n**r,w,x**三种权限可以用数字表示：\n\n- r ：--readable 4\n- w ：--writeable 2\n- x ： --executable 1\n\n不同身份的权限可以组合在一起：\n\n- user：rwx=4+2+1=7\n- group: rwx=4+2+1=7\n- others:r--=4\n\n则权限数字为774，加入要更改**file.txt**文件的权限为`-rwxrwxr--`，可以使用`chmod 774 file.txt`设置\n\n![image-20210818151215791](image-20210818151215791.png)\n\n","tags":["Linux"]},{"title":"Linux基本命令","url":"/2021/08/18/linux-based-command/","content":"\n## 列出目录-ls\n\n参数及说明：\n\n- -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n- -al ：将目录下的所有文件列出来(含属性与隐藏档)\n\n<!--more-->\n\n## 切换目录-cd\n\n参数及说明：\n\n- / ：回到根目录\n- .. ：回到上一级\n- ~ ：表示回到自己的家目录\n- home/ ：进入home目录\n\n\n\n## 显示目前所在的目录-pwd\n\n参数及说明：\n\n- : 单纯显示出目前的工作目录\n- -L ：`--logical`，显示当前的路径，有连接文件时，直接显示连接文件的路径，(不加参数时默认此方式)\n- -P ：`--physical`，显示当前的路径，有连接文件时，不使用连接路径，直接显示连接文件所指向的文件。当包含多层连接文件时，显示连接文件最终指向的文件，\n\n\n\n## 创建新目录-mkdir\n\n参数及说明：\n\n- -m ：`--mode`，建立目录的时候同时设置目录的权限\n- -p ：`--parents`，若所建立的上层目录目前尚未建立，则会一并建立上层目录\n\n\n\n## 删除空的目录-rmdir\n\n参数及说明：\n\n- -p ：用递归的方式删除指定的目录路径中的所有父级目录，非空则报错\n- -v ：显示命令的详细执行过程\n\n\n\n## 复制文件或目录-cp\n\n参数及说明：\n\n- -i ：若目标文件已存在，则会询问是否覆盖\n- -f ：若目标文件已存在，则会直接覆盖原文件\n- -p ：保留源文件或目录的所有属性\n- -r ：递归复制文件和目录\n- -l ：对源文件建立硬连接，而非复制文件\n- -s ：对源文件建立符号连接，而非复制文件\n- -v ：详细显示cp命令执行的操作过程\n\n\n\n## 移除文件或目录-rm\n\n参数及说明：\n\n- -f ：忽略不存在的文件，不会出现警告信息\n- -i ：删除前会询问用户是否操作\n- -r ：递归删除\n- -v ：显示指令的详细执行过程\n\n\n\n## 移动或改名文件-mv\n\n参数及说明：\n\n- -i ：若存在同名文件，则向用户询问是否覆盖\n- -f ：覆盖已有文件时，不进行任何提示\n- -b ：当文件存在时，覆盖前为其创建一个备份\n- -u ：当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作\n\n**参考实例**\n\n将文件file_1重命名为file_2：\n\n```sh\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# mv file_1 file_2\n```\n\n\n\n## 为文件创建链接-ln\n\nln命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是hard link，又称为硬链接；另一种是symbolic link，又称为符号链接。\n\n通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式。\n\n符号链接 ：\n\n- 符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。\n- 符号链接可以跨文件系统 ，硬链接不可以。\n- 符号链接可以对一个不存在的文件名进行链接，硬链接不可以。\n- 符号链接可以对目录进行链接，硬链接不可以。\n\n硬链接：\n\n- 硬链接以文件副本的形式存在，但不占用实际空间。\n- 硬链接不允许给目录创建硬链接。\n- 硬链接只有在同一个文件系统中才能创建。\n\n参数及说明：\n\n- -s ：对源文件建立符号链接，而非硬链接\n- -b ：删除，覆盖目标文件之前的备份\n- -d ：建立目录的硬连接\n\n**参考实例**\n\n为源文件file.txt创建硬链接file_1.txt\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# ln file.txt file_1.txt\n```\n\n\n\n## 输出字符串或提取Shell变量的值-echo\n\necho命令用于在终端设备上输出字符串或变量提取后的值，这是在Linux系统中最常用的几个命令之一，但操作却非常简单。\n\n人们一般使用在变量前加上$符号的方式提取出变量的值，例如：$PATH，然后再用echo命令予以输出。或者直接使用echo命令输出一段字符串到屏幕上，起到给用户提示的作用\n\n参数及说明：\n\n- -n ：不输出结尾的换行符\n- -e \"\\a\" ：发出警告音\n- -e \"\\n\" ：换行，光标移至行首\n\n**参考实例**\n\n输出一段字符串:\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# echo \"hello,world\"\nhello,world\n```\n\n输出变量提取后的值：\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n```\n\n对内容进行转义，不让$符号的提取变量值功能生效：\n\n```bash\n[root@iZ8vbb5zkeytv121vb0l5wZ ~]# echo \\$PATH\n$PATH\n```\n\n","tags":["Linux"]},{"title":"SpringBoot热部署配置","url":"/2021/08/12/springboot-hot-deployment/","content":"\n## SpringBoot热部署\n\nSpringBoot热部署是指当项目中的类或资源被修改后，不必重启整个应用即可更新类和资源，极大的提高了开发效率。\n\n<!--more-->\n\n> 关键是经常忘记在修改代码后重启应用，这点很头疼，而热部署完美的解决了这一点\n\n## 配置流程\n\n**导入Maven依赖**\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n```\n\n也可以在创建SpringBoot项目时直接添加**DevTools**工具\n\n![image-20210812103336594](image-20210812103336594.png)\n\n**运行/调试配置**\n\n更新策略全部设置为**更新类和资源**\n\n![image-20210812103854060](image-20210812103854060.png)\n\n**编译器配置**\n\n勾选自动构建项目\n\n![image-20210812104019837](image-20210812104019837.png)\n\n{% note info%}\n\n修改完类或资源之后，鼠标点击IDEA窗口之外的地方，热部署将会自动启动，也就是在你从IDEA切换至其他应用时热部署将会在无感的状态下进行\n\n{% endnote%}\n\n","tags":["SpringBoot"]},{"title":"在Vue项目中添加插件","url":"/2021/08/09/add-plugins-to-vue/","content":"\n## Vue Router\n\n### Vue CLI\n\n如果你有一个正在使用 [Vue CLI](https://cli.vuejs.org/zh/)的项目，你可以以项目插件的形式添加 Vue Router。CLI 可以生成上述代码及两个示例路由。它也会**覆盖**你的 `App.vue`，因此请确保在项目中运行以下命令之前备份这个文件：\n\n```sh\nvue add router\n```\n\n<!--more-->\n\n## Element UI\n\n### npm 安装\n\n推荐使用 npm 的方式安装，它能更好地和 [webpack](https://webpack.js.org/) 打包工具配合使用。\n\n```SH\nnpm i element-ui -S\n```\n\n另外还需再Vue项目中安装Element plugin\n\n```sh\nvue add element\n```\n\n\n\n","tags":["Vue"]},{"title":"跨域问题解决方案(SpringBoot)","url":"/2021/08/07/CORS-suport/","content":"\n## 什么是跨域访问\n\n说到跨域访问，必须先解释一个名词：同源策略。所谓同源策略就是在浏览器端出于安全考量，向服务端发起请求必须满足：协议相同、Host(ip)相同、端口相同的条件，否则访问将被禁止，该访问也就被称为跨域访问。\n\n<!--more-->\n\n虽然跨域访问被禁止之后，可以在一定程度上提高了应用的安全性，但也为开发带来了一定的麻烦。比如：我们开发一个前后端分离的项目，页面及js部署在一个主机的nginx服务中，后端接口部署在一个tomcat应用容器中，当前端向后端发起请求的时候一定是不符合同源策略的，也就无法访问。那么我们如何解决这个问题？就是本文需要向大家说明的内容。\n\n## 解决方案：CORS\n\n**CORS简介**\n\n>CORS是一个W3C标准，全称是\"跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。\n>\n>对于开发者来说，CORS通信与同源的AJAX/Fetch通信没有差别，代码完全一样。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n\n>  浏览器发出CORS简单请求，只需要在头信息之中增加一个Origin字段。\n>\n> 浏览器发出CORS非简单请求，会在正式通信之前，增加一次OPTIONS查询请求，称为\"预检\"请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n\n简单请求就是HEAD、GET、POST请求，并且HTTP的头信息不超出以下几种字段 Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type\n\n> 注：Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n反之，就是非简单请求。\n\n**第一种方案**\n\n自定义一个配置类继承自`WebMvcConfigurer`\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class CrossConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置\n                .allowedOriginPatterns(\"*\")//开放哪些ip、端口、域名的访问权限\n                .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")//开放哪些Http方法，允许跨域访问\n                .allowCredentials(true)//是否允许发送Cookie信息\n                .maxAge(3600)//预请求缓存时间，单位秒，默认为30分钟\n                .allowedHeaders(\"*\");//允许HTTP请求中的携带哪些Header信息\n    }\n}\n```\n\n**第二种解决方案**\n\n在controller类上使用`@CrossOrigin`注解\n\n```java\n@RestController\n@RequestMapping(\"/jdbc/user\")\npublic class UserController {\n    @Resource\n    private UserMapper userMapper;\n\n    @CrossOrigin\n    @RequestMapping(\"findAll\")\n    public List<User> findAll() {\n        return userMapper.selectList(null);\n    }\n}\n```\n\n> 当然也可在整个controller类上添加注解，这样controller内的所有请求都能被访问到\n\n查看`@CrossOrigin`注解\n\n```JAVA\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CrossOrigin {\n\t...\n}\n```\n\n从元注解@Target可以看出，注解可以放在method、class等上面，类似RequestMapping，也就是说，整个controller下面的方法可以都受控制，也可以让单个方法受控制。\n\n也可以得知，这个是最小粒度的CORS控制办法了，精确到单个请求级别。\n\n","tags":["SpringBoot"]},{"title":"创建一个Vue项目","url":"/2021/08/07/creating-a-project/","content":"\n## 使用图形化界面\n\n通过`vue ui`命令以图形化界面创建和管理项目：\n\n```SH\nvue ui\n```\n\n> 前提是你已经安装[Vue CLI ](https://cli.vuejs.org/zh/)\n\n<!--more-->\n\n上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。\n\n![](577324983751469300.jpg)\n\n输入项目名并把Git选项关闭，点击下一步\n\n![](212092649815764670.jpg)\n\n选择默认设置，创建项目\n\n![](373782839957865800.jpg)\n","tags":["Vue"]},{"title":"代码生成器(Mybatis-Plus)","url":"/2021/08/07/code-generator/","content":"\n## 添加依赖\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-generator</artifactId>\n    <version>3.4.1</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.velocity</groupId>\n    <artifactId>velocity-engine-core</artifactId>\n    <version>2.3</version>\n</dependency>\n```\n\n<!--more-->\n\n## 编写配置\n\nMyBatis-Plus 的代码生成器提供了大量的自定义参数供用户选择，能够满足绝大部分人的使用需求。\n\n- 配置 GlobalConfig\n\n```JAVA\nGlobalConfig globalConfig = new GlobalConfig();\nglobalConfig.setOutputDir(System.getProperty(\"user.dir\") + \"/src/main/java\");\nglobalConfig.setAuthor(\"catnyan\");\nglobalConfig.setOpen(false);\n```\n\n- 配置 DataSourceConfig\n\n```java\nDataSourceConfig dataSourceConfig = new DataSourceConfig();\ndataSourceConfig.setUrl(\"jdbc:mysql://localhost:3306/example?useUnicode=true&useSSL=false&characterEncoding=utf8\");\ndataSourceConfig.setDriverName(\"com.mysql.jdbc.Driver\");\ndataSourceConfig.setUsername(\"root\");\ndataSourceConfig.setPassword(\"123456\");\n```\n\n> 更多配置信息请查看[代码生成器配置](https://mp.baomidou.com/config/generator-config.html)\n\n## 定义代码生成器类\n\n```java\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.rules.DateType;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Scanner;\n\n\npublic class CodeGenerator {\n\n    public static String scanner(String tip) {\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append(\"请输入\" + tip + \"：\");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotBlank(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\n    }\n\n    public static void main(String[] args) {\n        // 1、创建代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 2、全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(\"user.dir\");\n        gc.setOutputDir(projectPath + \"/src/main/java\");\n        gc.setAuthor(\"catnyan\");\n        gc.setOpen(false); //生成后是否打开资源管理器\n        gc.setFileOverride(true); //重新生成时文件是否覆盖\n        gc.setServiceName(\"%sService\");    //去掉Service接口的首字母I\n        gc.setIdType(IdType.AUTO); //主键策略\n        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型\n        gc.setSwagger2(false);//开启Swagger2模式\n        mpg.setGlobalConfig(gc);\n\n        // 3、数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/example?serverTimezone=GMT%2B8\");\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"123456\");\n        dsc.setDbType(DbType.MYSQL);//数据库类型\n        mpg.setDataSource(dsc);\n\n        // 4、包配置\n        PackageConfig pc = new PackageConfig();\n        pc.setParent(\"com.catnyan\");\n        pc.setModuleName(scanner(\"模块名\"));\n        pc.setController(\"controller\");\n        pc.setEntity(\"entity\");\n        pc.setService(\"service\");\n        pc.setMapper(\"mapper\");\n        mpg.setPackageInfo(pc);\n\n        // 5、策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\n        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略\n        strategy.setTablePrefix(pc.getModuleName() + \"_\"); //生成实体时去掉表前缀\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略\n        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作\n        strategy.setRestControllerStyle(true); //restful api风格控制器\n        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符\n        mpg.setStrategy(strategy);\n\n        // 6、执行\n        mpg.execute();\n    }\n}\n```\n","tags":["Mybatis-Plus"]},{"title":"条件构造器(Mybatis-Plus)","url":"/2021/08/05/conditional-constructor/","content":"\n## wrapper\n\n**常用两大类：**\n\n- **QueryWrapper** ： Entity 对象封装操作类，不是用lambda语法\n- **UpdateWrapper** ： Update 条件封装，用于Entity对象更新操作\n\n<!--more-->\n\n使用方法：\n\n```java\n    @Test\n    void wrapper() {\n        QueryWrapper<User> wrapper = new QueryWrapper<>();\n        wrapper.eq(\"name\", \"van\")\n                .eq(\"password\", \"123\");\n        List<User> users = userMapper.selectList(wrapper);\n        users.forEach(System.out::println);\n    }\n```\n\n> wrapper用来保存查询条件，上述代码表示查询所有`name`为`van`且`password`为`123`的记录\n\n执行结果：\n\n```txt\n==>  Preparing: SELECT id,name,password,create_time,update_time,version,deleted FROM user WHERE deleted=0 AND (name = ? AND password = ?)\n==> Parameters: van(String), 123(String)\n<==    Columns: id, name, password, create_time, update_time, version, deleted\n<==        Row: 2, van, 123, null, 2021-08-05 14:28:38.404, 2, 0\n<==      Total: 1\n```\n\n## 查询条件说明\n\n| 函数名  | 说明               |\n| ------- | ------------------ |\n| eq      | 等于 =             |\n| ne      | 不等于 =           |\n| gt      | 大于 >             |\n| ge      | 大于等于 >=        |\n| lt      | 小于 <             |\n| le      | 小于等于 <=        |\n| between | between值1 and 值2 |\n| like    | LIKE ‘%值%'        |\n| ...     | ...                |\n\n>更多**查询条件**信息可查看[官方指南](https://mp.baomidou.com/guide/wrapper.html#abstractwrapper)\n\n","tags":["Mybatis-Plus"]},{"title":"分页插件(Mybatis-Plus)","url":"/2021/08/05/Pagination/","content":"\n## 分页配置\n\n在`MybatisPlusConfig`自定义类中开启分页插件\n\n```java\n@Component\n@MapperScan(\"com.catnyan.mapper\")\npublic class MybatisPlusConfig {\n    /**\n     * 新版3.4.3.1\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();\n        //开启分页插件\n        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));\n        \n        return mybatisPlusInterceptor;\n    }\n}\n\n```\n\n<!--more-->\n\n## 使用分页\n\n```java\n    @Test\n    void page() {\n        Page<User> page = new Page<>(1, 2);//第一页最多显示两条记录\n        userMapper.selectPage(page, null);\n        page.getRecords().forEach(System.out::println);\n    }\n```\n\n执行结果：\n\n```txt\n==>  Preparing: SELECT id,name,password,create_time,update_time,version,deleted FROM user WHERE deleted=0 LIMIT ?\n==> Parameters: 2(Long)\n<==    Columns: id, name, password, create_time, update_time, version, deleted\n<==        Row: 1, name, 123456, null, null, 1, 0\n<==        Row: 2, van, 123, null, 2021-08-05 14:28:38.404, 2, 0\n<==      Total: 2\n```\n\n","tags":["Mybatis-Plus"]},{"title":"字段自动填充(Mybatis-Plus)","url":"/2021/08/05/Auto-fill/","content":"\n对于表中日期类的属性我们想要系统自动来完成创建和更新，但并非所有数据库都支持，而且也不建议通过修改数据库来实现这一功能，好消息是Mybatis-Plus也拥有自动填充的功能，坏消息是好像有点小问题。\n\n<!--more-->\n\n## 官方教程\n\n官方的做法是在需要自动填充的字段上加上`@TableField(fill = FieldFill.INSERT)`注解，然后再自定义一个实现MetaObjectHandler结构的实现类且注册为Bean\n\n**注解用法**\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n    private String name;\n    private String password;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n}\n```\n\n**字段填充策略枚举类**\n\n```java\npublic enum FieldFill {\n    /**\n     * 默认不处理\n     */\n    DEFAULT,\n    /**\n     * 插入时填充字段\n     */\n    INSERT,\n    /**\n     * 更新时填充字段\n     */\n    UPDATE,\n    /**\n     * 插入和更新时填充字段\n     */\n    INSERT_UPDATE\n}\n```\n\n**自定义实现类MyMetaObjectHandler**\n\n```java\n@Slf4j\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    /*插入时的填充策略*/\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        log.info(\"start insert fill ....\");\n        this.strictInsertFill(metaObject, \"createTime\", Date::new, Date.class);\n    }\n\n    /*更新时的填充策略*/\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        log.info(\"start update fill ....\");\n        this.strictUpdateFill(metaObject, \"updateTime\", Date::new, Date.class);\n    }\n}\n```\n\n\n\n然而执行插入操作后却仅带有`FieldFill.INSERT`的字段`createTime`被更新了，而带有`FieldFill.INSERT_UPDATE`的字段`updateTime`却没有更新，很奇怪\n\n```TXT\n==>  Preparing: INSERT INTO user ( name, password, create_time, update_time ) VALUES ( ?, ?, ?, ? )\n==> Parameters: dd(String), 123456(String), 2021-08-05 13:15:23.961(Timestamp), null\n<==    Updates: 1\n```\n\n## 解决方案\n\n既然`FieldFill.INSERT_UPDATE`无效，那就在`insertFill`方法中再添加一条`strictUpdateFill`语句，这样每次插入新数据时，`createTime`和`updateTime`都将会自动创建\n\n> 所以`FieldFill.INSERT_UPDATE`到底有什么用，仅仅是用来看的吗\n\n```java\n@Slf4j\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    /*插入时的填充策略*/\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        log.info(\"start insert fill ....\");\n        this.strictInsertFill(metaObject, \"createTime\", Date::new, Date.class);\n        this.strictUpdateFill(metaObject, \"updateTime\", Date::new, Date.class);\n    }\n\n    /*更新时的填充策略*/\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        log.info(\"start update fill ....\");\n        this.strictUpdateFill(metaObject, \"updateTime\", Date::new, Date.class);\n    }\n}\n```\n\n","tags":["Mybatis-Plus"]},{"title":"java中的::是什么意思？","url":"/2021/08/04/What-does-double-colon-in-java-mean/","content":"\n## forEach(System.out::println)\n\n```java\nfor (String s : str){\n\tSystem.out.println(s);\n}\n```\n\n上面的代码我们已经很熟悉了，可`forEach(System.out::println)`是什么鬼？\n\n其实这是lambda表达式的进一步精简，等价于`forEach((x)->System.out.println(x))`\n\n<!--more-->\n\n**lambda 表达式允许4种方式的双冒号**\n\n| 种类                     | 使用方法                 | 对应的lambda表达式                    |\n| ------------------------ | ------------------------ | ------------------------------------- |\n| 应用特定对象的实例方法   | Object :: instanceMethod | (a,b,...)->特定对象.实例方法(a,b,...) |\n| 引用类对象               | Class :: staticMethod    | (a,b,...)->类名.类方法(a,b,...)       |\n| 引用某个类对象的实例方法 | Class :: instanceMethod  | (a,b,...)->A.实例方法(a,b,...)        |\n| 引用构造器               | Class :: new             | (a,b,...)->new 类名(a,b,...)          |\n\n","tags":["java"]},{"title":"Sequence键(Mybatis-Plus)","url":"/2021/08/04/SequencePrimarykey/","content":"\n## @TableId\n\n在实体类的主键字段上添加`@TableId`注解，指定生成ID类型即可完成主键的设置\n\n例如：\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    /*type的不同取值在IdType枚举类中进行了定义，见后续内容*/\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n    private String name;\n    private String password;\n}\n```\n\n<!--more-->\n\n测试代码：\n\n```java\n@Test\nvoid insert() {\n    User user = new User();\n    user.setName(\"aa\");\n    user.setPassword(\"123456\");\n    userMapper.insert(user);\n}\n```\n\n> 插入数据时，不必再设置主键值，系统将自动添加\n\n## IdType枚举类源码\n\n```java\n@Getter\npublic enum IdType {\n    /**\n     * 数据库ID自增\n     * <p>该类型请确保数据库设置了 ID自增否则无效</p>\n     */\n    AUTO(0),\n    /**\n     * 该类型为未设置主键类型，即表未设置主键\n     */\n    NONE(1),\n    /**\n     * 用户输入ID\n     * <p>该类型可以通过自己注册自动填充插件进行填充</p>\n     */\n    INPUT(2),\n\n    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。*/\n    /**\n     * 分配ID (主键类型为number或string）,\n     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法)\n     *\n     * @since 3.3.0\n     */\n    ASSIGN_ID(3),\n    /**\n     * 分配UUID (主键类型为 string)\n     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace(\"-\",\"\"))\n     */\n    ASSIGN_UUID(4);\n\n    private final int key;\n\n    IdType(int key) {\n        this.key = key;\n    }\n}\n\n```\n\n","tags":["Mybatis-Plus"]},{"title":"SpringBoot整合Mybatis-Plus","url":"/2021/08/04/SpringBootIntegrationMybatis-Plus/","content":"\n## 添加依赖\n\n引入Spring Boot Starter 父工程：\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>spring-latest-version</version>\n    <relativePath/>\n</parent>\n```\n\n<!--more-->\n\n引入 `spring-boot-starter`、`spring-boot-starter-test` 依赖：\n\n```xml\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n```\n\n>上述过程均可通过SpringBoot快速初始化自动完成 \n\n引入`mybatis-plus-boot-starter`、`mysql` 依赖：\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3.1</version>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.26</version>\n</dependency>\n```\n\n> [当前Mybatis-Plus最新版本](https://search.maven.org/search?q=g:com.baomidou%20a:mybatis-*)\n\n## 配置\n\n在 `application.yaml` 配置文件中添加`mysql` 数据库的相关配置：\n\n```yaml\n# DataSource Config\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=GMT%2B8\n    username: root\n    password: 123456\n```\n\n在 Spring Boot 启动类中添加 `@MapperScan` 注解，扫描 Mapper 文件夹：\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.catnyan.mapper\")\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(QuickStartApplication.class, args);\n    }\n\n}\n```\n\n## 编码\n\n编写实体类 `User.java`\n\n```java\n@Data\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}\n```\n\n编写Mapper类 `UserMapper.java`\n\n```java\npublic interface UserMapper extends BaseMapper<User> {\n\n}\n```\n\n## 开始使用\n\n```java\n@SpringBootTest\npublic class SampleTest {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void testSelect() {\n        System.out.println((\"----- selectAll method test ------\"));\n        List<User> userList = userMapper.selectList(null);\n        Assert.assertEquals(5, userList.size());\n        userList.forEach(System.out::println);\n    }\n\n}\n```\n\n> TIP\n>\n> UserMapper 中的 `selectList()` 方法的参数为 MP 内置的条件封装器 `Wrapper`，所以不填写就是无任何条件\n\n控制台输出：\n\n```text\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\nUser(id=4, name=Sandy, age=21, email=test4@baomidou.com)\nUser(id=5, name=Billie, age=24, email=test5@baomidou.com)\n```\n\n## 配置日志\n\n```yaml\n# 方式一\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl \n    \n# 方式二 application.yml 中增加配置，指定 mapper 文件所在的包\nlogging:\n  level:\n    com.baomidou.example.mapper: debug\n```\n\n","tags":["Mybatis-Plus"]},{"title":"IoC是什么？为什么要用？","url":"/2021/07/30/What-is-IoC/","content":"\n\n\n在学习java后端的过程，spring框架已经是一个绕不开的话题，其中的新技术我们虽然会用却很少有人会思考问什么要用这个技术，IoC就是如此，因此在讨论IoC是什么之前，我想先讨论为什么Spring要引入这项技术。\n\n<!--more-->\n\n## 为什么要用IoC?\n\n假设我们现在没有Spring框架可用，也没有什么所谓的Ioc，仅仅用传统的Servlet开发项目\n\n#### 传统开发模式\n\n三层架构是经典的开发模式，我们一般将视图控制、业务逻辑和数据库操作分别抽离出来单独形成一个类，这样各个职责就非常清晰且易于复用和维护。大致代码如下：\n\n**视图控制层：**\n\n```java\n@WebServlet(\"/user\")\npublic class UserServlet extends HttpServlet {\n    // 用于执行业务逻辑的对象\n    private UserService userService = new UserServiceImpl();\n    \n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 其他代码\n            \n        // 执行业务逻辑\n        userService.doService();\n        \n        // ...返回页面视图\n    }\n}\n```\n\n**业务逻辑层**\n\n```java\npublic class UserServiceImpl implements UserService{\n    // 用于操作数据库的对象\n    private UserDao userDao = new UserDaoImpl();\n    \n    @Override\n    public void doService() {\n        // 业务逻辑代码\n            \n        // 执行数据库操作\n        userDao.doUpdate();\n        \n        // 业务逻辑代码\n    }\n}\n```\n\n**数据库操作层**\n\n```java\npublic class UserDaoImpl implements UserDao{\n    @Override\n    public void doUpdate() {\n        // JDBC代码\n    }\n    @Override\n    public void doQuery(){\n        //JDBC代码\n    }    \n}\n```\n\n上层依赖下层，抽象之后如下图：\n\n![](1931196-20210205095805653-769853086.jpg)\n\n业界普遍按这种分层方式组织代码，其核心思想是职责分离。层次越低复用程度越高，比如一个 DAO 对象往往会被多个 Service 对象使用，一个 Service 对象往往也会被多个 Controller 对象使用：\n\n![](1931196-20210205095805789-1102447808.jpg)\n\n条理分明，井然有序。这些被复用的对象就像一个个的组件，供多方使用。\n\n虽然这个倒三角看上去非常漂亮，然而我们目前的代码有一个比较大的问题，那就是我们只做到了**逻辑复用**，并没有做到**资源复用**。\n\n上层调用下一层时，必然会持有下一层的对象引用，即成员变量。目前我们每一个成员变量都会实例化一个对象，如下图所示：\n\n![](1931196-20210205095805944-276583550.jpg)\n\n每一个链路都创建了同样的对象，造成了极大的资源浪费。许多组件只需要实例化一个对象就够了，创建多个没有任何意义。针对对象重复创建的问题，我们自然而然想到了单例模式。只要编写类时都将其写为单例，这样就避免了资源浪费。但是，引入设计模式必然会带来复杂性，况且还是每一个类都为单例，每一个类都会有相似的代码，其弊端不言自明。\n\n\n\n仅仅是资源的浪费倒还好，因为可以堆硬件，然而三层架构还有另一个一个致命缺陷，那就是**变化的代价太大**。\n\n假设有 10 个 Controller 依赖了 UserService，最开始实例化的是 `UserServiceImpl`，后面需要换一个实现类 `OtherUserServiceImpl`，我就得逐个修改那 10 个 Controller，非常麻烦。更换实现类的需求可能不会太多，没多大说服力。那咱们看另一个情况。\n\n传统创建组件的过程非常简单，`new`一下就行了，可很多时候创建一个组件没那么容易。比如 DAO 对象要依赖一个这样的数据源组件：\n\n```java\npublic class UserDaoImpl implements UserDao{\n    private MyDataSource dataSource;\n\n    public UserDaoImpl() {\n        // 构造数据源\n        dataSource = new MyDataSource(\"jdbc:mysql://localhost:3306/mybatis\", \"root\", \"123456\");\n        // 进行一些其他配置\n        dataSource.setInitiaSize(10);\n        dataSource.setMaxActive(100);\n        // ...省略更多配置项\n    }\n}\n```\n\n该数据源组件要想真正生效需要对其进行许多配置，这个创建和配置过程是非常麻烦的。而且配置可能会随着业务需求的变化经常更改，这时候你就需要修改每一个依赖该组件的地方，牵一发而动全身。这还只是演示了一个数据源的创建配置过程，真实开发中可有太多组件和太多配置需要编码了，其麻烦程度堪称恐怖。\n\n> 当然，这些问题都可以引入设计模式来解决，不过这样一来又绕回去了：设计模式本身也会带来复杂性。这就像一种死循环：传统开发模式编码复杂，要想解决这种复杂却得陷入另一种复杂。\n\n难道没有办法解决了吗？当然不是的，在引出解决方案前，我们先来梳理一下目前出现的问题：\n\n- 创建了许多重复对象，造成大量资源浪费\n- 更换实现类需要改动多个地方\n- 创建和配置组件工作繁杂，给组件调用方带来极大不便  \n\n透过现象看本质，这些问题的出现都是同一个原因：**组件的调用方参与了组件的创建和配置工作**。\n\n>就相当于你去下馆子，想要吃饭还要自己去后厨做饭一样，显然这不符合常理\n\n其实调用方只需关注组件如何调用，至于这个组件如何创建和配置又与调用方有什么关系呢？我去餐馆吃饭应该只需点菜，饭菜并不需要我亲自去做，餐馆自然会做好给我送过来。如果我们编码时，有一个「东西」能帮助我们创建和配置好那些组件，我们只负责调用该多好。这个「东西」就是容器。\n\n容器这一概念我们已接触过，Tomcat 就是 Servlet 的容器，它帮我们创建并配置好 Servlet，我们只需编写业务逻辑即可。试想一下，如果 Servlet 要我们自己创建，HttpRequest、HttpResponse 对象也需要我们自己配置，那代码量得有多恐怖。\n\nTomcat 是 Servlet 容器，只负责管理 Servlet。我们平常使用的组件则需要另一种容器来管理，这种容器我们称之为 **IoC 容器**。\n\n\n\n##  IoC是什么？\n\n通过上面的讲解，相比你已经对IoC的诞生背景有了一定的了解，接下来我们就来介绍IoC究竟是什么。\n\n#### 控制反转和依赖注入\n\nIoC(Inversion of Control),又名控制反转，是指对象的创建和配置的控制权从调用方转移给容器，而不必再通过传统方式`new`出来，IoC已经帮我们做好了这一切。\n\n有了 IoC 容器，我们可以将对象交由容器管理，交由容器管理后的对象称之为 Bean。调用方不再负责组件的创建，要使用组件时直接通过注解获取 Bean 即可：\n\n```java\n@Component\npublic class UserServiceImpl implements UserService{\n    @Autowired // 获取 Bean\n    private UserDao userDao;\n}\n```\n\n>我只想说注解永远的神 \n\n调用方只需按照约定声明依赖项，所需要的 Bean 就自动配置完毕了，就好像在调用方外部注入了一个依赖项给其使用，所以这种方式称之为 **依赖注入**（Dependency Injection，缩写为 DI）。\n\n**控制反转和依赖注入是一体两面，都是同一种开发模式的表现形式**。\n\nIoC 轻而易举地解决了我们刚刚总结的问题：\n\n- 对象交由容器管理后，默认是单例的，这就解决了资源浪费问题。\n\n- 若要更换实现类，只需更改 Bean 的声明配置，即可达到无感知更换：\n\n```JAVA\n@Component\npublic class UserServiceImpl implements UserService{\n    ...\n}\n\n// 将该实现类声明为 Bean\n@Component\npublic class OtherUserServiceImpl implements UserService{\n    ...\n}\n```\n\n现在组件的使用和组件的创建与配置完全分离开来。调用方只需调用组件而无需关心其他乱七八糟的东西，这极大提高了我们的开发效率，也让整个应用充满了灵活性、扩展性。\n\n这样看来，我们如此中意 IoC 不是没有道理的。\n","tags":["Spring"]},{"title":"注解Autowired与Resource的区别","url":"/2021/07/29/ResouceAndAutowired/","content":"\n### 注解来源\n\n@Autowired是Spring框架所定义的注解，而@Resource是JSR-250规范定义的注解，你可以在spring中同时使用这两个注解\n\n<!-- more -->\n\n## @Autowired\n\n- 由Spring提供，只按照**byType**注入\n\n- 只有一个属性required,默认值为true，表示注入时对应的bean必须存在，找不到则抛出异常，为false时，找不到就跳过并赋值为null\n\n- 按照**类型**进行查找，如果对应类型的bean不唯一，将抛出异常  \n\n  - 可通过组合注解解决\n\n    ```java\n    @Autowired\n    @Qualifier(\"userMapperImpl\")\n    private UserMapper userMapper;\n    ```\n\n      \t\t\n\n## @Resource\n\n@Resource有两个常用属性：name、type，因此存在四种注入情况\n\n1. 都不指定，即默认情况下：先通过name作为key去查找，如果找不到再通过type去查找，如果找不到或结果不唯一则抛出异常\n2. 指定name:通过name找到唯一的bean，找不到将抛出异常\n3. 指定type:通过type找到唯一的bean，如果不唯一或找不到则抛出异常\n4. 指定name和type:通过name找到唯一的bean，找不到抛出异常；如果type和字段类型不一致，也会抛出异常\n\n\n\n## 相同点\n\n1. Spring都支持\n2. 都可以作用在字段和setter方法上\n\n\n\n## 不同点\n\n1. Resource是JDK提供的，而Autowired是Spring提供的\n2. Resource不允许找不到bean的情况，而Autowired可以允许`@Autowired(required = false)`\n3. 指定name的方式不一样\n   - `@Resource(name = \"baseDao\")`\n   - `@Autowired()@Qualifier(\"baseDao\")`\n4. Resource默认通过name查找，而Autowired默认通过type查找\n\n---\n\n推荐使用@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与Spring的耦合。\n\n","tags":["注解"]}]